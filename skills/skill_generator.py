# skills/skill_generator.py  v2.4
"""
Skill Generator——自我进化引擎。

关键能力（三）：自我进化
  Agent 可根据用户反馈自动生成新 Skill 并注册。

工作流程：
  1. 用户反馈某个操作很常用（或 Agent 检测到重复调用模式）
  2. SkillGenerator 调用 LLM 生成 skill.md + skill.py
  3. 将文件写入 skills/<new_skill_dir>/
  4. 调用 SkillLoader.hot_add() 热注册
  5. 新 Skill 立即可用，无需重启

安全约束：
  - 生成的 skill.py 在沙盒中先验证（dry_run=True）
  - 生成的代码不允许包含 import os.system / subprocess.Popen / eval / exec
  - 所有生成的 Skill 自动打上 "auto_generated" 标签
"""

import os
import re
from datetime import datetime, timezone
from pathlib import Path

FORBIDDEN_PATTERNS = [
    r"\bos\.system\s*\(",
    r"\bsubprocess\.(run|Popen|call|check_output)\s*\(",
    r"\beval\s*\(",
    r"\bexec\s*\(",
    r"\b__import__\s*\(",
    r"\bimportlib\.import_module\s*\(",
]

SKILL_MD_TEMPLATE = '''---
name: "{name}"
category: "{category}"
description: "{description}"
when_to_use: "{when_to_use}"
version: "1.0.0"
author: "auto_generated"
tags: {tags}
requires: []
enabled: true
---

# {name}

{description}

## 使用时机

{when_to_use}

## 输入参数

{input_description}

## 输出格式

返回 Envelope 格式，包含 outputs.summary_for_llm.result_brief 和 outputs.full_log。
'''

SKILL_PY_TEMPLATE = '''# skills/{dir_name}/skill.py  (auto-generated by SkillGenerator v2.4)
"""
{description}

自动生成于：{generated_at}
"""

from datetime import datetime, timezone


def run(args: dict) -> dict:
    """
    {description}

    Args:
        args: 输入参数字典

    Returns:
        Envelope 格式字典（符合 envelope_v2.4.json schema）
    """
    # ── 参数提取 ─────────────────────────────────────────────────────────────
{arg_extraction}

    # ── 核心逻辑 ─────────────────────────────────────────────────────────────
    # TODO: 在此处实现具体逻辑
    result = {{
        "message": f"Skill {name!r} 已自动生成，请实现具体逻辑",
        "args_received": args,
    }}

    # ── 返回 Envelope ─────────────────────────────────────────────────────────
    return {{
        "outputs": {{
            "status": "ok",
            "summary_for_llm": {{
                "result_brief": f"{{name}} 执行完成",
                "structured_data": result,
                "artifact_refs": [],
                "next_step_hint": None,
                "error_brief": None,
            }},
            "full_log": {{
                "research_log": [{{
                    "t":       datetime.now(timezone.utc).isoformat(),
                    "stage":   "run",
                    "message": f"[{{name}}] 执行完成",
                }}],
                "artifacts": [],
                "provenance": [],
            }},
        }}
    }}
'''


class SkillGenerator:
    """
    Skill 自动生成器。

    支持两种工作模式：
      1. LLM 辅助生成（推荐）：调用 LLM 生成完整的 skill.md + skill.py
      2. 模板生成（快速）：基于用户提供的参数填充模板
    """

    def __init__(
        self,
        skills_root: str | Path,
        loader,           # SkillLoader 实例
        llm=None,         # LLM 实例（可选，用于辅助生成）
    ):
        self.skills_root = Path(skills_root)
        self.loader = loader
        self.llm = llm

    def generate_from_template(
        self,
        name: str,
        category: str,
        description: str,
        when_to_use: str,
        tags: list[str] | None = None,
        input_params: list[dict] | None = None,
        dry_run: bool = False,
    ) -> dict:
        """
        基于模板生成新 Skill（快速模式）。

        Args:
            name:         Skill 名称（命名空间格式）
            category:     类别
            description:  描述
            when_to_use:  使用时机
            tags:         标签列表
            input_params: 输入参数定义列表
            dry_run:      True 时只生成内容不写入文件

        Returns:
            {"success": bool, "skill_dir": str, "skill_meta": SkillMeta | None, "error": str | None}
        """
        tags = tags or []
        input_params = input_params or []

        # 确保 auto_generated 标签
        if "auto_generated" not in tags:
            tags = ["auto_generated"] + tags

        # 生成目录名（从 name 的最后一段）
        dir_name = name.replace(".", "_")

        # 生成参数提取代码
        arg_lines = []
        for param in input_params:
            pname = param.get("name", "param")
            pdefault = param.get("default", "None")
            arg_lines.append(f'    {pname} = args.get("{pname}", {pdefault!r})')

        arg_extraction = "\n".join(arg_lines) if arg_lines else '    # 无必须参数'

        # 参数描述（用于 skill.md）
        if input_params:
            input_desc_lines = []
            for p in input_params:
                input_desc_lines.append(
                    f"- `{p.get('name')}` ({p.get('type', 'str')}): "
                    f"{p.get('description', '')}"
                    + (f"，默认 {p.get('default')!r}" if "default" in p else "")
                )
            input_description = "\n".join(input_desc_lines)
        else:
            input_description = "无必须参数"

        generated_at = datetime.now(timezone.utc).isoformat()

        md_content = SKILL_MD_TEMPLATE.format(
            name=name,
            category=category,
            description=description,
            when_to_use=when_to_use,
            tags=str(tags),
            input_description=input_description,
        )

        py_content = SKILL_PY_TEMPLATE.format(
            name=name,
            dir_name=dir_name,
            description=description,
            generated_at=generated_at,
            arg_extraction=arg_extraction,
        )

        # 安全检查
        safety_result = _check_code_safety(py_content)
        if not safety_result["safe"]:
            return {
                "success": False,
                "skill_dir": None,
                "skill_meta": None,
                "error": f"安全检查失败：{safety_result['reason']}",
            }

        if dry_run:
            return {
                "success": True,
                "skill_dir": str(self.skills_root / dir_name),
                "md_content": md_content,
                "py_content": py_content,
                "skill_meta": None,
                "error": None,
            }

        # 写入文件
        skill_dir = self.skills_root / dir_name
        skill_dir.mkdir(parents=True, exist_ok=True)

        (skill_dir / "skill.md").write_text(md_content, encoding="utf-8")
        (skill_dir / "skill.py").write_text(py_content, encoding="utf-8")

        # 热注册
        skill_meta = self.loader.hot_add(skill_dir)

        if skill_meta:
            return {
                "success": True,
                "skill_dir": str(skill_dir),
                "skill_meta": skill_meta,
                "error": None,
            }
        else:
            return {
                "success": False,
                "skill_dir": str(skill_dir),
                "skill_meta": None,
                "error": "文件已写入但热加载失败，请检查 skill.py 语法",
            }

    async def generate_with_llm(
        self,
        user_request: str,
        existing_skill_names: list[str] | None = None,
        dry_run: bool = False,
    ) -> dict:
        """
        使用 LLM 生成新 Skill（高质量模式）。

        Args:
            user_request:          用户描述的新能力需求
            existing_skill_names:  已有 Skill 名称列表（避免重复）
            dry_run:               True 时只生成不写入

        Returns:
            同 generate_from_template 返回格式
        """
        if self.llm is None:
            return {
                "success": False,
                "skill_dir": None,
                "skill_meta": None,
                "error": "LLM 未配置，无法使用 LLM 辅助生成模式",
            }

        from langchain_core.messages import HumanMessage

        prompt = _build_generation_prompt(user_request, existing_skill_names or [])
        response = await self.llm.ainvoke([HumanMessage(content=prompt)])
        content = response.content

        # 从 LLM 输出中提取 skill.md 和 skill.py
        md_content, py_content = _extract_skill_files(content)
        if not md_content or not py_content:
            return {
                "success": False,
                "skill_dir": None,
                "skill_meta": None,
                "error": "LLM 输出格式不符合要求，无法提取 skill.md 和 skill.py",
            }

        # 安全检查
        safety_result = _check_code_safety(py_content)
        if not safety_result["safe"]:
            return {
                "success": False,
                "skill_dir": None,
                "skill_meta": None,
                "error": f"LLM 生成代码安全检查失败：{safety_result['reason']}",
            }

        if dry_run:
            return {
                "success": True,
                "skill_dir": None,
                "md_content": md_content,
                "py_content": py_content,
                "skill_meta": None,
                "error": None,
            }

        # 从 md_content 提取 name 字段
        import yaml as _yaml
        lines = md_content.split("\n")
        try:
            end = lines.index("---", 1)
            meta = _yaml.safe_load("\n".join(lines[1:end]))
            skill_name = meta.get("name", f"auto.generated.{_ts()}")
        except Exception:
            skill_name = f"auto.generated.{_ts()}"

        dir_name = skill_name.replace(".", "_")
        skill_dir = self.skills_root / dir_name
        skill_dir.mkdir(parents=True, exist_ok=True)

        (skill_dir / "skill.md").write_text(md_content, encoding="utf-8")
        (skill_dir / "skill.py").write_text(py_content, encoding="utf-8")

        skill_meta = self.loader.hot_add(skill_dir)
        return {
            "success": skill_meta is not None,
            "skill_dir": str(skill_dir),
            "skill_meta": skill_meta,
            "error": None if skill_meta else "热加载失败",
        }


# ─── 内部工具函数 ──────────────────────────────────────────────────────────────

def _check_code_safety(code: str) -> dict:
    """检查生成代码中是否含有危险模式。"""
    for pattern in FORBIDDEN_PATTERNS:
        if re.search(pattern, code):
            return {
                "safe": False,
                "reason": f"检测到危险模式：{pattern}",
            }
    return {"safe": True, "reason": None}


def _build_generation_prompt(user_request: str, existing_skill_names: list[str]) -> str:
    """构建给 LLM 的 Skill 生成 Prompt。"""
    existing_str = "\n".join(f"  - {n}" for n in existing_skill_names) if existing_skill_names else "  （无）"
    return f"""你是一个 Biomni Skill 生成专家。
请根据以下用户需求，生成一个新的 Biomni Skill。

## 用户需求
{user_request}

## 已有 Skill（避免重复）
{existing_str}

## 输出要求
请生成两个文件内容：

### skill.md
```yaml
---
name: "命名空间.类别.功能名"  # 示例：tcm.database.herb_query
category: "database|analysis|visualization|general"
description: "简短描述（不超过 100 字）"
when_to_use: "何时调用（详细说明）"
version: "1.0.0"
author: "auto_generated"
tags: ["tag1", "tag2"]
requires: []
enabled: true
---

详细说明...
```

### skill.py
```python
from datetime import datetime, timezone

def run(args: dict) -> dict:
    # 实现逻辑
    return {{
        "outputs": {{
            "status": "ok",
            "summary_for_llm": {{
                "result_brief": "结果简述",
                "structured_data": {{}},
                "artifact_refs": [],
                "next_step_hint": None,
                "error_brief": None,
            }},
            "full_log": {{
                "research_log": [],
                "artifacts": [],
                "provenance": [],
            }},
        }}
    }}
```

请严格按照上述格式输出，不要包含危险操作（os.system, subprocess, eval, exec）。
"""


def _extract_skill_files(llm_output: str) -> tuple[str, str]:
    """从 LLM 输出中提取 skill.md 和 skill.py 内容。"""
    md_match = re.search(r"```(?:yaml|markdown)?\n(---.*?---.*?)```", llm_output, re.DOTALL)
    py_match = re.search(r"```python\n(.*?)```", llm_output, re.DOTALL)

    md_content = md_match.group(1).strip() if md_match else ""
    py_content = py_match.group(1).strip() if py_match else ""

    return md_content, py_content


def _ts() -> str:
    return datetime.now(timezone.utc).strftime("%Y%m%d%H%M%S")
